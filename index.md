The widespread use of open-source software (OSS) has led to extensive code reuse, making vulnerabilities in OSS significantly pervasive. The vulnerabilities due to code reuse in OSS are commonly known as vulnerable code clones (VCCs) or recurring vulnerabilities. Existing approaches primarily employ clone-based techniques to detect recurring vulnerabilities through matching vulnerable functions in software projects. These techniques do not incorporate specially-designed mechanisms for vulnerabilities with multiple fixing functions (VM). Typically, they generate a signature for each fixing function and report VM using a matching-one-in-all approach. However, the variation in vulnerability context across diverse fixing functions results in varying accuracy levels in detecting VMs, potentially limiting the effectiveness of existing methods.

In this paper, we introduce VMUD, a novel approach for detecting Vulnerabilities with Multiple Fixing Functions (VM). VMUD identifies vulnerable function clones (VCCs) through function matching similar to existing methods. However, VMUD takes a different approach by only selecting the critical functions from VM for signature generation, which are a subset of the fixing functions. This step ensures VMUD to focus on fixing functions that offer sufficient knowledge about the VM. To cope with the potential decrease in recall due to excluding the remaining fixing functions, VMUD employs semantic equivalent statement matching using these critical functions. It aims to uncover more VM by creating two signatures of each critical function and match precisely by contextual semantic equivalent statement mapping on the two signatures. Our evaluation has demonstrated that VMUD surpasses state-of-the-art vulnerability detection approaches by 17.6% in terms of F1-Score. Furthermore, VMUD has successfully detected 275 new VM across 84 projects, with 42 confirmed cases and 5 assigned CVE identifiers.

The paper has been submitted to CCS 2024.    

This page lists the supplementary materiales that are omitted from the paper due to space limitations, provides the surveying questions of our study, and releases the code for tool.

### Dataset

- **signature**: VMud starts by giving an input as a CVE ID and traces patches to find the vulnerability-fixing commit in two ways. First, it searches the CVE ID in open-source software repositoriesâ€™ histories with vulnerability keywords and filters out irrelevant commits. The irrelevant commits include reverted commits, merging commits, etc. Second, it leverages the National Vulnerability Database (NVD) reference pages for silent fixes (*i.e.*, commits without explicit CVE ID mentions). This database provides valuable metadata and refer encing pages related to CVE fixes. Finally, we collect 810 VMs, the dataset can be download [here](dataset/VMs.json), and you can get original signature X~org~ and rephrased signature X~rep~ which is generated by [gen_fingerprint_multi_org.py](vmud/fingerprint/gen_fingerprint_multi_org.py) and [gen_fingerprint_multi_rep.py](vmud/fingerprint/gen_fingerprint_multi_org.py) respectively in [signature_org](https://github.com/vmud20/vmud20.github.io/tree/main/dataset/signature_org) and [signature_rep](https://github.com/vmud20/vmud20.github.io/tree/main/dataset/signature_rep) 
- **Target Project Selection.** We established three criteria for project selection. Firstly, projects should be written in C/C++. Secondly, they should be popular in popularity and span diverse domains. Thirdly, they should be actively maintained. Subsequently, we collected 972 projects from GitHub by querying the Top 1000 popular projects ranked by their stars using GitHub API. These projects encompass areas such as databases, operating systems, image processing, reverse development, etc. The project list is shown [here](dataset/projects.json)


### Source code

##### Signature generation

- **Input:**CVE-ID, Project's path affected by CVE, patch commit file path (patch commit file can be obtained through git show + commit hash)

- **Output**: 

  - a directory named *vulFileMulti*: Files containing vulnerable functions
  - a file named *sagaMulti.json*: The line number information of the vulnerability method in the file
  - the signature file named *CVE-XXXX-XXXX.json*

- **vulFileMulti construction:**

  For each commit file, it consists of several modified file fragments, where each fragment starts from a line beginning with 'diff --git' and ends at the next line beginning with 'diff --git' or at the end of the file. Within each file fragment, the line starting with 'index' contains the hash values of the file before and after the commit, separated by "..". By using the command 'git show' followed by the corresponding hash value, we can obtain the file information before the commit. Hence, we utilize the hash value before ".." and output it to the 'vulFileMulti' folder.

- **sagaMulti.json construction:**

   Follow the instructions provided in [Instructions for Utilizing SAGA](https://github.com/vmud20/vmud20.github.io/tree/main/vmud/detector/Instructions for Utilizing SAGA.md) to execute SAGA, analyzing the path of *vulFileMulti*. Subsequently, locate the index number corresponding to the method modified by the patch commit in the generated *result/MeasureIndex.csv*. Record the starting line number of the method index. Initially, add the information in the format *CVEID Number of Modified Methods* to *sagaMulti.json*. Next, append the information in the format *File Name Starting Line Number of Method* to *saga.json*.

- **signature generation:**

  - **List of File:**

    - *normalize.sc*: scala script to extract the positional information of formal parameters, local variables, type declarations, and method invocations using Joern
    - *slice.sc*: scala script to get the method's Program Dependency Graph(PDG) via Joern
    - *metadata.sc*: scala script to retrieve the list of methods for a specified file using Joern
    - *get_condition.sc*: scala script to get the positional information of expression which need to rephrase via Joern
    - *getMacros.py*: python script to extract all macros involved in patch files.
    - *gen_fingerprint_multi_rep.py*: python script to get the rephrased signature *Xrep*
    - *gen_fingerprint_multi_org.py*: python script to get the original signature *Xorg*
    - *config_sigs.json*: configuration file for signature generation
    - *pagerank.py*: python script to get the PageRank score of each modified function in the patch.
    - *config.py*: configuration file for PageRank score generation.

  - **configuration for signature generation:** the modifiable parameters include:
  
    - *signature_path*: the absolute path to store signature
    - *work_path*: the absolute path to the directory of joern-cli
    - *macros*: the absolute path to store macros
    - *ctagsPath*: the absolute path to the directory of ctags tool
  
  - **configuration for PageRank:**
  
    - *Doxygen_conf_location*: the absolute path to the directory of doxygen.
    - *work_path*: the absolute path to the directory of joern-cli
    - *error_log_file*:the path to the error log file
    - *timeout_repo_list_file*: the file path to record repository information for timeouts
    - *method_info_location*: the file path to record method information
    - *no_define_location_prefix*: the directory path to store the call graph information
    - *jump_threshold*: call graph jump threshold, the default is 3
    - *subprocess_exec_max_time_sec*: the time limit for call graph generation, specified in seconds, the default is 4 hours
    - *subprocess_exam_time_sec*: the polling frequency for call graph generation process, specified in seconds, the default is 1minute
    - *file_num_threshold*: the scale of files involved in the call graph, the default is 5000
    - *pagerank_location_prefix*: the directory path to store the PageRank score files.
  
  - **Runtime environment**:
  
    1. **Joern :** we use the version of 1.1.1377. 
  
       The installation process for Joern can be found at https://docs.joern.io/installation.
  
       To install and run Joern, JDK 11 environment is required.
  
    2. **doxygen:**  we use the version of 1.10. 
  
       The installation process for Joern can be found at https://github.com/doxygen/doxygen.
  
    3. **Python**: The required libraries for the version include json, os, hashlib, re, sys, queue, and xml.
  
    4. **ctags:** The installation process for ctags can be found at https://github.com/universal-ctags/ctags.
  
  - **generation steps:**
  
    - **PageRank score generation:** please place the files *metadata.sc*, *pagerank.py*, and *config.py* into the *joern-cli* directory. Ensure that the directory includes executable files such as *joern*, *joern-parse*, and *joern-flow*. After complete the relevant entries in the configuration file, just run the following command:
  
      ```bash
      python pagerank.py CVE_ID commit_file_location git_repo_location
      ```
  
      It will generate the corresponding PageRank score information file for the CVE-ID in the directory specified in the configuration file for PageRank.
  
      - **CVE_ID**: the CVE-ID for which PageRank score files need to be generated.
      - **commit_file_location**: the file paths of patch commit files for CVEs for which PageRank files need to be generated.
      - **git_repo_location:** the GitHub repository paths corresponding to CVEs for which PageRank files need to be generated.
  
      **For the vulnerability patches we have used in evaluation, we have already generated all [PageRank score](https://github.com/vmud20/vmud20.github.io/tree/main/dataset/pagerank) of each modified function in the patch.**
  
    - **preprocess step:** if you want to generate X~rep~, you need to extract all macros involved in patch files. After complete the relevant entries in the configuration file, just run the following command:
  
      ```bash
      python getMacros.py CVE_ID commit_file_location git_repo_location
      ```
  
      - **CVE_ID**: the CVE-ID corresponding to the patch file.
      - **commit_file_location**: the absolute path to the file storing GitHub commit content.
      - **git_repo_location:** the absolute path to the directory of the GitHub repository corresponding to the CVE.
  
      **For the vulnerability patches we have collected, we have already extracted all [macros](https://github.com/vmud20/vmud20.github.io/tree/main/dataset/macros4sig) involved in each patch.**
  
    - **generation step:** please place the files (*normalize.sc*, *gen_fingerprint_multi_rep.py*, *gen_fingerprint_multi_org.py*,  *config_sigs.json* *slice.sc*, *metadata.sc*, *get_condition.sc*) into the *joern-cli* directory. Ensure that the directory includes executable files such as *joern*, *joern-parse*, and *joern-flow*. After complete the relevant entries in the configuration file, just run the following command:
  
      ```
      python gen_fingerprint_multi.py CVE_ID commit_file_location git_repo_location
      ```
  
      - **gen_fingerprint_multi.py**: refers to *gen_fingerprint_multi_rep.py* or *gen_fingerprint_multi_org.py*
  
      - **CVE_ID**: the CVE-ID corresponding to the patch file.
  
      - **commit_file_location**: the absolute path to the file storing GitHub commit content.
  
      - **git_repo_location:** the absolute path to the directory of the GitHub repository corresponding to the CVE.

##### Detector

- **List of File:**

  - *normalize_per.sc*: scala script to extract the positional information of formal parameters, local variables, type declarations, and method invocations using Joern
  - *slice_per.sc*: scala script to get the method's Program Dependency Graph(PDG) via Joern
  - *metadata.sc*: scala script to retrieve the list of methods for a specified file using Joern
  - *getCondition_per.sc*: scala script to get the positional information of expression which need to rephrase via Joern
  - *thrown_cve.pkl*: the list of CVEs removed due to the limitations of the Joern and Doxygen tools
  - *sagaMulti.json*: the line number information of the vulnerability method in the file
  - *saga*: a clone detection tool saga
  - *vulFileMulti*: files containing vulnerable functions
  - *config.json*: configuration for detector
  - *Detector.py*: python script to implement vmud
  - *Instructions for Utilizing SAGA.md*: a instruction for SAGA
  
- **configuration for detector:**

  - *signature_path*: the absolute path to store rephrased signature X~rep~
  - *work_path*: the absolute path to the directory of joern-cli
  - *saga_path*: the absolute path to the directory of SAGA
  - *progress_file*: the path of log file
  - *saga_multi*: the path of *sagaMulti.json*
  - *vulFileMulti*: the path of *vulFileMulti*
  - *ctagsPath*: the absolute path to the directory of ctags tool
  - *tempSignature*: the path to store the detected repository's signature
  - *signature_path_org*:  the absolute path to store original signature X~org~
  - *targetRepoMacros*:  the absolute path to store macros
  - *pagerank_location_prefix*: the directory path to store the PageRank score files.
  - *pagerank_threshold*: PageRank score threshold, the default is 0.018

- **Runtime environment**:

  - **Joern :** we use the version of 1.1.1377. 

    The installation process for Joern can be found at https://docs.joern.io/installation.

    To install and run Joern, JDK 11 environment is required.

  - **Python**: The required libraries for the version include json, os, hashlib, re, sys, queue, xml, pickle and networkx.
  - **ctags:** The installation process for ctags can be found at https://github.com/universal-ctags/ctags.
  
- **Detector**

  1. In the *joern-cli* directory (which should include executable files such as *joern*, *joern-parse*, and *joern-flow*), create five folders named *temp*, *slicingJson*, *normalizeJson*, *normalized*, and *conditionJson*. 

  2. Please place the following files in the *joern-cli* directory: *normalize_per.sc*, *Detector.py*, *slice_per.sc*, *metadata.sc*, *getCondition_per.sc*, *thrown_cve.pkl* and *config.json*. The folders *vulFileMulti* and *ctags*, along with the *saga* folder and *sagaMulti.json* file, have no specific placement restriction.
  
  3. After complete the relevant entries in the configuration file, just run the following command:

     ```bash
     python Detector.py detect_dir
     ```
  
     The tool will output the detected recurring vulnerability results to the *resultMulti.txt* file in the *joern-cli* directory.

     - *detect_dir* refers to absolute path for repository that needed to be detected

### Evaluation

TBD