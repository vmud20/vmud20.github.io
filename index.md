The widespread use of open-source software (OSS) has led to extensive code reuse, making vulnerabilities in OSS significantly pervasive. The vulnerabilities due to code reuse in OSS are commonly known as vulnerable code clones (VCCs) or recurring vulnerabilities. Existing approaches primarily employ clone-based techniques to detect recurring vulnerabilities through matching vulnerable functions in software projects. These techniques do not incorporate specially-designed mechanisms for vulnerabilities with multiple fixing functions (VM). Typically, they generate a signature for each fixing function and report VM using a matching-one-in-all approach. However, the variation in vulnerability context across diverse fixing functions results in varying accuracy levels in detecting VMs, potentially limiting the effectiveness of existing methods.

In this paper, we introduce VMUD, a novel approach for detecting Vulnerabilities with Multiple Fixing Functions (VM). VMUD identifies vulnerable function clones (VCCs) through function matching similar to existing methods. However, VMUD takes a different approach by only selecting the critical functions from VM for signature generation, which are a subset of the fixing functions. This step ensures VMUD to focus on fixing functions that offer sufficient knowledge about the VM. To cope with the potential decrease in recall due to excluding the remaining fixing functions, VMUD employs semantic equivalent statement matching using these critical functions. It aims to uncover more VM by creating two signatures of each critical function and match precisely by contextual semantic equivalent statement mapping on the two signatures. Our evaluation has demonstrated that VMUD surpasses state-of-the-art vulnerability detection approaches by 17.6% in terms of F1-Score. Furthermore, VMUD has successfully detected 275 new VM across 84 projects, with 42 confirmed cases and 5 assigned CVE identifiers.

The paper has been submitted to CCS 2024.    

This page lists the supplementary materiales including the dataset, source code and reproducing scripts of our paper.

### Dataset

- **VM Signature**: VMud starts by giving an input as a CVE ID and traces patches to find the vulnerability-fixing commit in two ways. First, it searches the CVE ID in open-source software repositoriesâ€™ histories with vulnerability keywords and filters out irrelevant commits. The irrelevant commits include reverted commits, merging commits, etc. Second, it leverages the National Vulnerability Database (NVD) reference pages for silent fixes (*i.e.*, commits without explicit CVE ID mentions). This database provides valuable metadata and refer encing pages related to CVE fixes. Finally, we collect 810 VMs, the dataset can be download [here](dataset/VMs.json), and you can get original signature *Xorg* and rephrased signature *Xrep* which is generated by [gen_fingerprint_multi_org.py](vmud/fingerprint/gen_fingerprint_multi_org.py) and [gen_fingerprint_multi_rep.py](vmud/fingerprint/gen_fingerprint_multi_org.py) respectively in [signature_org](https://github.com/vmud20/vmud20.github.io/tree/main/dataset/signature_org) and [signature_rep](https://github.com/vmud20/vmud20.github.io/tree/main/dataset/signature_rep).
- **Target Project Selection.** We established three criteria for project selection. Firstly, projects should be written in C/C++. Secondly, they should be popular in popularity and span diverse domains. Thirdly, they should be actively maintained. Subsequently, we collected 972 projects from GitHub by querying the Top 1000 popular projects ranked by their stars using GitHub API. These projects encompass areas such as databases, operating systems, image processing, reverse development, etc. The project list is shown [here](dataset/projects.json).

### Runtime environment:

1. **Joern :** we use the version of 1.1.1377. 

   The installation process for Joern can be found at https://docs.joern.io/installation.

   To install and run Joern, JDK 11 environment is required.

2. **doxygen:**  we use the version of 1.10. 

   The installation process for Joern can be found at https://github.com/doxygen/doxygen.

3. **Python**: The required libraries for the version include json, os, hashlib, re, sys, queue, xml, pickle and networkx.

4. **ctags:** The installation process for ctags can be found at https://github.com/universal-ctags/ctags.

### Source code

Our code can be download [here](https://github.com/vmud20/vmud20.github.io/tree/main/vmud), The code is divided into two directories: *signatureGeneration* and *VMDetector*. To generate signatures, execute the Python script named ***gen_fingerprint_multi_org.py* or *gen_fingerprint_multi_rep.py***. Besides, to conduct VM detection for a specific project, run the Python script ***Detector.py*** to obtain the detection results."

##### VM Signature generation

- **Input:** CVE-ID, Project's path affected by CVE, patch commit file path (patch commit file can be obtained through git show + commit hash)

- **Output**: 

  - a directory named *vulFileMulti*: Files containing vulnerable functions
  - a file named *sagaMulti.json*: The line number information of the vulnerability method in the file
  - the signature file named *CVE-XXXX-XXXX.json*
  - PageRank score of each modified function(**For the vulnerability patches we have used in evaluation, we have already generated all [PageRank score](https://github.com/vmud20/vmud20.github.io/tree/main/dataset/pagerank) of each modified function in the patch.**)
  - all macros involved in patch files(**For the vulnerability patches we have collected, we have already extracted all [macros](https://github.com/vmud20/vmud20.github.io/tree/main/dataset/macros4sig) involved in each patch.**)

- **signature generation:**

  - **List of File:**

    - *normalize.sc*: scala script to extract the positional information of formal parameters, local variables, type declarations, and method invocations using Joern
    - *slice.sc*: scala script to get the method's Program Dependency Graph(PDG) via Joern
    - *metadata.sc*: scala script to retrieve the list of methods for a specified file using Joern
    - *get_condition.sc*: scala script to get the positional information of expression which need to rephrase via Joern
    - *getMacros.py*: python script to extract all macros involved in patch files.
    - *gen_fingerprint_multi_rep.py*: python script to get the rephrased signature *Xrep*
    - *gen_fingerprint_multi_org.py*: python script to get the original signature *Xorg*
    - *config_sigs.json*: configuration file for signature generation
    - *pagerank.py*: python script to get the PageRank score of each modified function in the patch.
    - *config.py*: configuration file for PageRank score generation.
    - *saga*: a clone detection tool saga
  
  - **configuration for signature generation:** the modifiable parameters include:
  
    - *signature_path*: the absolute path to store signature
    - *work_path*: the absolute path to the directory of joern-cli
    - *macros*: the absolute path to store macros
    - *ctagsPath*: the absolute path to the directory of ctags tool
    - *saga_path*: the absolute path to the directory of SAGA
  
  - **configuration for PageRank:**
  
    - *Doxygen_conf_location*: the absolute path to the directory of doxygen.
    - *work_path*: the absolute path to the directory of joern-cli
    - *error_log_file*:the path to the error log file
    - *timeout_repo_list_file*: the file path to record repository information for timeouts
    - *method_info_location*: the file path to record method information
    - *no_define_location_prefix*: the directory path to store the call graph information
    - *jump_threshold*: call graph jump threshold, the default is 3
    - *subprocess_exec_max_time_sec*: the time limit for call graph generation, specified in seconds, the default is 4 hours
    - *subprocess_exam_time_sec*: the polling frequency for call graph generation process, specified in seconds, the default is 1minute
    - *file_num_threshold*: the scale of files involved in the call graph, the default is 5000
    - *pagerank_location_prefix*: the directory path to store the PageRank score files.
  
  - **generation step:** please place the files (*normalize.sc*, *gen_fingerprint_multi_rep.py*, *gen_fingerprint_multi_org.py*,  *config_sigs.json* *slice.sc*, *metadata.sc*, *get_condition.sc*) into the *joern-cli* directory. Ensure that the directory includes executable files such as *joern*, *joern-parse*, and *joern-flow*. After complete the relevant entries in the configuration file, just run the following command:
  
    ```
    python gen_fingerprint_multi.py CVE_ID commit_file_location git_repo_location
    ```
  
    - **gen_fingerprint_multi.py**: refers to *gen_fingerprint_multi_rep.py* or *gen_fingerprint_multi_org.py*
  
    - **CVE_ID**: the CVE-ID corresponding to the patch file.
  
    - **commit_file_location**: the absolute path to the file storing GitHub commit content.
  
    - **git_repo_location:** the absolute path to the directory of the GitHub repository corresponding to the CVE.

##### VMUD

- **List of File:**

  - *normalize_per.sc*: scala script to extract the positional information of formal parameters, local variables, type declarations, and method invocations using Joern
  - *slice_per.sc*: scala script to get the method's Program Dependency Graph(PDG) via Joern
  - *metadata.sc*: scala script to retrieve the list of methods for a specified file using Joern
  - *getCondition_per.sc*: scala script to get the positional information of expression which need to rephrase via Joern
  - *thrown_cve.pkl*: the list of CVEs removed due to the limitations of the Joern and Doxygen tools
  - *sagaMulti.json*: the line number information of the vulnerability method in the file
  - *saga*: a clone detection tool saga
  - *vulFileMulti*: files containing vulnerable functions
  - *config.json*: configuration for detector
  - *Detector.py*: python script to implement vmud
  - *Instructions for Utilizing SAGA.md*: a instruction for SAGA
  
- **configuration for detector:**

  - *signature_path*: the absolute path to store rephrased signature *Xrep*
  - *work_path*: the absolute path to the directory of joern-cli
  - *saga_path*: the absolute path to the directory of SAGA
  - *progress_file*: the path of log file
  - *saga_multi*: the path of *sagaMulti.json*
  - *vulFileMulti*: the path of *vulFileMulti*
  - *ctagsPath*: the absolute path to the directory of ctags tool
  - *tempSignature*: the path to store the detected repository's signature
  - *signature_path_org*:  the absolute path to store original signature *Xorg*
  - *targetRepoMacros*:  the absolute path to store macros
  - *pagerank_location_prefix*: the directory path to store the PageRank score files.
  - *pagerank_threshold*: PageRank score threshold, the default is 0.018

- **Detector**

  1. In the *joern-cli* directory (which should include executable files such as *joern*, *joern-parse*, and *joern-flow*), create five folders named *temp*, *slicingJson*, *normalizeJson*, *normalized*, and *conditionJson*. 

  2. Please place the following files in the *joern-cli* directory: *normalize_per.sc*, *Detector.py*, *slice_per.sc*, *metadata.sc*, *getCondition_per.sc*, *thrown_cve.pkl* and *config.json*. The folders *vulFileMulti* and *ctags*, along with the *saga* folder and *sagaMulti.json* file, have no specific placement restriction.
  
  3. After complete the relevant entries in the configuration file, just run the following command:

     ```bash
     python Detector.py detect_dir
     ```
  
     The tool will output the detected recurring vulnerability results to the *resultMulti.txt* file in the *joern-cli* directory.

     - *detect_dir* refers to absolute path for repository that needed to be detected

### Evaluation

TBD